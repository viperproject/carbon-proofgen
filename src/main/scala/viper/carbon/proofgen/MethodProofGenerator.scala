package viper.carbon.proofgen

import isabelle.ast
import viper.silver.{ast => sil}
import isabelle.ast._

import scala.collection.mutable.ListBuffer
import isabelle.ast.ProofUtil._
import isabelle.ast.IsaUtil._
import isabelle.ast.MLUtil.{isaToMLThm, isaToMLThms, mlTacticToIsa}


case class MethodProofGenerator(
                    theoryName: String,
                    vprProg: IsaMethodAccessor,
                    vprTranslation: VarTranslation[sil.LocalVar],
                    boogieProg: IsaBoogieProcAccessor)
{

  val varContextViperName = "var_ctxt_viper"
  val varContextBoogieName = "var_ctxt_bpl"
  val typeInterpBplName = "type_interp_bpl"

  val viperProgram = TermIdent("Pr_trivial")

  val varRelationListName = "var_relation_list_1"
  val translationRecordName = "tr_vpr_bpl_0"
  val stateRelInitialName = "state_rel_initial"

  val tyReprBasic = TermIdent("ty_repr_basic")
  val constReprBasic = TermIdent("const_repr_basic")

  val funReprConcrete = TermIdent("fun_repr_concrete")

  def generateProof() : Theory = {

    val outerDecls : ListBuffer[OuterDecl] = ListBuffer.empty

    val viperVarContextDef = DefDecl(
      varContextViperName,
      Some(ArrowType(IsaTypeUtil.natType, IsaTypeUtil.optionType(ViperIsaType.viperTyType))),
      (Seq(), IsaTermUtil.mapOf(vprProg.methodArgs()))
    )

    outerDecls += viperVarContextDef

    val varRelationList = {
      TermList(
        vprTranslation.availableVariables().map(
          vprVar => {
            val vprVarId = vprTranslation.translateVariableId(vprVar).get
            val bplVarId = boogieProg.getBoogieVarId(vprVar)
            TermTuple(Seq(NatConst(vprVarId), NatConst(bplVarId)))
          }
        )
      )
    }

    val varRelationListDef = DefDecl(
      varRelationListName,
      None,
      (Seq(), varRelationList)
    )

    outerDecls += varRelationListDef

    val translationRecord = TranslationRecord.makeTranslationRecord(
      heapVar = NatConst(boogieProg.getVarId(HeapGlobalVar)),
      maskVar = NatConst(boogieProg.getVarId(MaskGlobalVar)),
      maskRead = TermApp(TermIdent("read_mask_concrete"), TermIdent("fun_repr_concrete")),
      heapRead = TermApp(TermIdent("read_heap_concrete"), TermIdent("fun_repr_concrete")),
      fieldTranslation = TermIdent("f_None"),
      funTranslation = TermIdent("f_None"),
      varTranslation = IsaTermUtil.mapOf(TermIdent(varRelationListDef.name)),
      /* TODO: the constants representation should be generated by Carbon and not hardcoded */
      constRepr = constReprBasic
    )

    val translationRecordDef = DefDecl(translationRecordName,
      Some(TranslationRecord.translationRecordType),
      (Seq(), translationRecord))

    outerDecls += translationRecordDef

    outerDecls += DeclareDecl(s"${TranslationRecord.translationRecordTypeName}.defs(1)[simp]")

    val varContextBplAbbrev = AbbrevDecl(varContextBoogieName,
      None,
      (Seq(), boogieProg.varContext)
    )

    outerDecls += varContextBplAbbrev

    val stateRelInitialAbbrev: AbbrevDecl  =
      AbbrevDecl(
        stateRelInitialName,
        None,
        (Seq(TermIdent("ctxt"), TermIdent("w"), TermIdent("ns")),
          ViperBoogieRelationIsa.stateRelation(
            viperProgram,
            tyReprBasic,
            TermIdent(translationRecordDef.name),
            TermIdent("ctxt"),
            TranslationRecord.maskVar(TermIdent(translationRecordDef.name)),
            TermIdent("w"),
            TermIdent("w"),
            TermIdent("ns")
          )
        )
      )

    outerDecls += stateRelInitialAbbrev

    val typeInterpBplAbbrev: AbbrevDecl =
      AbbrevDecl(
        typeInterpBplName,
        None,
        (Seq(), ViperBoogieRelationIsa.viperBoogieAbstractTypeInterp(tyReprBasic))
      )

    outerDecls += typeInterpBplAbbrev

    outerDecls += mainProofLocale()

    Theory(
      theoryName = theoryName,
      importTheories = Seq(
        "TotalViper.ExpProofGenTest",
        "TotalViper.ViperBoogieTranslationInterface",
        "TotalViper.ExprWfRelML",
        "TotalViper.CPGHelperML",
        "TotalViper.StmtRelML",
        "Boogie_Lang.TypingML",
        vprProg.methodTheoryPath,
        boogieProg.procTheoryPath
      ),
      decls = outerDecls.toSeq
    )
  }

  private def mainProofLocale() : LocaleDecl = {
    val exprContextBpl = TermIdent("ectxt")

    val bplCtxtWfLabel = "CtxtWf"

    val funInterpWfBpl = "WfFunBpl"

    val contextElem = ContextElem(
      //fixes
      Seq( (exprContextBpl, ViperBoogieRelationIsa.expressionContextType(VarType("'a"))) ),

      //assumes
      Seq( (Some("VarContextBpl [simp]"), TermBinary.eq(BoogieExpressionContext.varContext(exprContextBpl), TermIdent(varContextBoogieName))),
           (Some("TyInterpBpl [simp]"), TermBinary.eq(BoogieExpressionContext.typeInterp(exprContextBpl), TermIdent(typeInterpBplName))),
        (Some(bplCtxtWfLabel), BoogieExpressionContext.wellFormed(
           viperProgram = viperProgram,
            tyReprBpl = tyReprBasic,
          fieldMap = TermIdent("f_None"),
           funMap = funReprConcrete,
          exprContextBpl
          ) ),
        (Some(funInterpWfBpl), BoogieIsaTerm.funInterpWf(
          typeInterp = BoogieExpressionContext.typeInterp(exprContextBpl),
          funDecls = boogieProg.funDecls,
          funInterp = BoogieExpressionContext.funInterp(exprContextBpl)
          ))
      )
    )

    val xId = SimpleIdentifier("x")
    val tId = SimpleIdentifier("t")

    val varContextWfBplLemma =
      LemmaDecl(
        "var_ctxt_bpl_wf",
        ContextElem.empty(),
        TermQuantifier(All, Seq(xId, tId),
          TermBinary.implies(
            TermBinary.eq(BoogieIsaTerm.lookupVarTy(BoogieExpressionContext.varContext(exprContextBpl), TermIdent(xId)), IsaTermUtil.some(TermIdent(tId))),
            BoogieIsaTerm.wfTy(TermIdent(tId))
          )
        ),
        Proof(Seq(using(boogieProg.varContextWfThm, byTac(simp))))
      )

    val outerDecls : ListBuffer[OuterDecl] = ListBuffer.empty
    outerDecls += varContextWfBplLemma

    val lookupVarRelTac = "tac1"
    val litRelTac = "tac2"
    val typeSafetyThmMap = "type_safety_thm_map"
    val expRelInfo = "exp_rel_info"
    val stmtRelInfo = "stmt_rel_info"
    val stmtRelHints = "stmt_rel_hints"

    val mlInitializationCode =
      Seq(
        MLUtil.defineVal(lookupVarRelTac, MLUtil.simp(isaToMLThms(Seq(definitionLemmaFromName(translationRecordName), definitionLemmaFromName(varRelationListName))))),
        MLUtil.defineVal(litRelTac, MLUtil.simp(isaToMLThms(Seq(definitionLemmaFromName(translationRecordName))))),
        MLUtil.defineVal(typeSafetyThmMap, ViperBoogieMLUtil.genTypeSafetyThmMap(
          isaToMLThm(funInterpWfBpl),
          isaToMLThm(boogieProg.funDeclsWf.toString),
          isaToMLThm(varContextWfBplLemma.name),
          isaToMLThm(ViperBoogieRelationIsa.stateRelationWellTypedThm.toString)
          )
        ),

        //TODO: more fine-grained approach (specify required lookup theorems for different expressions)
        // TODO: take lookup theorems for constants and globals into account
        MLUtil.defineVal("lookupThms", isaToMLThms(
          boogieProg.getAllLocalVariables().map(l => boogieProg.getLookupThyThm(l)).toSeq)
        ),
        MLUtil.defineVal(expRelInfo, ViperBoogieMLUtil.createExpRelInfo(typeSafetyThmMap, lookupVarRelTac, litRelTac, "lookupThms")),
        MLUtil.defineVal(stmtRelInfo, ViperBoogieMLUtil.createStmtRelInfo(
          isaToMLThm(bplCtxtWfLabel),
          isaToMLThm(definitionLemmaFromName(translationRecordName)),
          lookupVarRelTac,
          "assm_full_simp_solved_with_thms_tac " + isaToMLThms(Seq(definitionLemmaFromName(varContextViperName))))
        ),
        MLUtil.defineVal(stmtRelHints, stmtRelHints)
      )

    outerDecls += MLDecl(mlInitializationCode, MLNormal)

    val mainTheorem = LemmaDecl("method_rel_proof",
      ContextElem.empty(),
      ViperBoogieRelationIsa.stmtRel(
        stateRelEnter=ViperBoogieRelationIsa.stateRelEmpty(TermApp(TermIdent(stateRelInitialName), exprContextBpl)),
        stateRelExit=TermApp(TermIdent(stateRelInitialName), exprContextBpl),
        totalContextVpr=TermIdent("total_context_trivial"),
        stateConsistency=TermIdent("StateCons"),
        varContextVpr=TermIdent(varContextViperName),
        programVpr=TermIdent("P"),
        expressionContextBpl=exprContextBpl,
        stmtVpr= vprProg.methodBody(),
        configBplEnter=ViperIsaTerm.convertAstToProgramPoint(TermIdent(boogieProg.procBodyAstDef)),
        configBplExit=BoogieIsaTerm.finalProgramPoint),
      Proof(
        initBoogieStateProof(bplCtxtWfLabel) ++
        mainProof(stmtRelHints, stmtRelHints) ++
        Seq(doneTac)
      )
    )

    outerDecls += mainTheorem

    LocaleDecl("method_proof", contextElem, outerDecls.toSeq)
  }

  private def mainProof(stmtRelInfo: String, stmtRelTacHints: String) : Seq[String] = {
    Seq(
      applyTac(unfoldTac(IsaUtil.definitionLemmaFromName(vprProg.methodBody().toString))),
      applyTac(ViperBoogieRelationIsa.stmtRelPropagatePreSameRelTac),
      applyTac(ViperBoogieRelationIsa.stmtRelTac(MLUtil.contextAniquotation, stmtRelInfo, stmtRelTacHints)),
      applyTac(ViperBoogieRelationIsa.progressBplTac(MLUtil.contextAniquotation)),
    )
  }

  private def initBoogieStateProof(ctxtBplWfThm: String): Seq[String] = {
    Seq(
      applyTac(unfoldTac(Seq(IsaUtil.definitionLemmaFromName(ViperBoogieRelationIsa.stateRelEmptyName),
                             IsaUtil.definitionLemmaFromName(boogieProg.procBodyAstDef)))),
      applyTac(BoogieIsaTerm.simplifyAstToProgramPointTac),
      applyTac(ViperBoogieRelationIsa.stmtRelPropagatePreTac),
      applyTac(ruleTac("exI")),
      applyTac(BoogieIsaTerm.unfoldASTBlockInGoalTac),
      applyTac(BoogieIsaTerm.redAstPropagateRelTac),
      applyTac(BoogieIsaTerm.redAstOneSimpleCmdTac),
      applyTac(BoogieIsaTerm.assignIntroAltTac),
      applyTac(simpTac(boogieProg.getLookupThyThm(MaskGlobalVar))),
      applyTac(ruleTac(BoogieIsaTerm.redVarThm)),
      applyTac(ViperBoogieRelationIsa.zeroMaskLookupTactic(IsaUtil.definitionLemmaFromName(translationRecordName))),
      applyTac(simpTac(IsaUtil.definitionLemmaFromName(tyReprBasic.toString))),
    ) ++
      initUpdatedStateInRelation() ++
      initAssumeGoodState(ctxtBplWfThm)
  }

  private def initUpdatedStateInRelation() : Seq[String] = {
    Seq(
      applyTac(ruleTac(ViperBoogieRelationIsa.stateRelMaskUpdateThm)),
      applyTac(fastforceTac),
      applyTac(simpTac),
      applyTac(ruleTac(ViperBoogieRelationIsa.zeroMaskRelThm)),
      applyTac(simpTac),
      applyTac(simpTac(IsaUtil.definitionLemmaFromName(translationRecordName))),
      applyTac(simpTac),
      applyTac(simpTac)
    )
  }

  private def initAssumeGoodState(ctxtBplWfThm: String) : Seq[String] = {
    Seq(
      applyTac(BoogieIsaTerm.redAstPropagateRelTac),
      applyTac(BoogieIsaTerm.redAstOneSimpleCmdTac),
      applyTac(ViperBoogieRelationIsa.redAssumeGoodStateTac(IsaUtil.definitionLemmaFromName(translationRecordName),
        MLUtil.isaToMLThm(ctxtBplWfThm)
        )),
      applyTac(assumeTac),
      applyTac(ruleTac("conjI")),
      applyTac(simpTac),
      applyTac(BoogieIsaTerm.redAstReflTac),
      applyTac(assumeTac)
    )
  }

}
